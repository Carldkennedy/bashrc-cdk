sacctu() {
            sacct --user="$1" --format=Account,AveCPU,AveRSS,AveVMSize,CPUTime,Elapsed,ExitCode,JobID,JobName,MaxRSS,MaxVMSize,MaxDiskRead,MaxDiskWrite,ReqCPUS,ReqMem,ReqNodes,NCPUS,NNodes;
 }

sstatu() {
            sstat --jobs="$1" --format=AveCPU,AveRSS,AveVMSize,JobID,MaxRSS,MaxVMSize,NTasks;
 }
 
jobinfo() {
    echo -e "\n###################### Failed jobs scripts ####################### \n"
    sacct --format="JobID,JobName%50,State,ExitCode,Start,End" --state=FAILED -j $1
    echo -e "\n########################### In queue ############################# \n"
    squeue -j $1
    echo -e "\n########################## Finished jobs ########################## \n"
    sacct --format="JobID,JobName%50,State,ExitCode,Start,End" --state=COMPLETED -j $1
}

userinfo() {
    clear
    echo -e "\n##################### Recently finished jobs ###################### \n"
    sacct -u $1 --format=JobID,JobName,Partition,AllocCPUS,State,ExitCode,Start,End,Elapsed

    echo -e "\n############################ CANCELLED ############################ \n"
    sacct -u $1 --state CANCELLED --format=JobID,JobName,Partition,AllocCPUS,State,ExitCode,Start,End,Elapsed

    echo -e "\n########################### Processes ############################# \n" 
    ps aux | grep $1

    echo -e "\n############################# squeue ############################## \n"
    squeue -u $1

    eval df -h "~$1"
}
#Bess
modep() { # A function to display available modules and their dependencies
    if [[ $# -eq 0 ]]; then # If no arguments are provided
        echo "Usage: modep <module_name>. This function is case sensitive!"
    else
        modules=($(module -t avail 2>&1 $1)) # Get a list of available modules matching the provided name
        for module in "${modules[@]}"; do # For each available module

            num_slashes=$(echo "$module" | tr -dc '/' | wc -c) # Count the number of slashes in the module name to see if it's a path
            if [[ "$num_slashes" -ge 6 ]]; then # If there are at least 6 slashes in the name i.e it's in /usr/local/modulefiles/*/eb/
                search_dir="$(echo "$module" | cut -d/ -f1-6)" # Set the search directory to the everything before the first 6 slashes
            else
                                if [[ "$num_slashes" == 5 ]]; then
                                        continue
                                else
                                        echo "$module" # Print the module name
                                        modepx "$module" "$search_dir" # Otherwise, call the modepx function with the module name and search directory
                                fi
            fi
        done
    fi
}

modepx() { # A recursive function to display a module's dependencies
    deps=($(grep -rl "^    module load ${1}" "${2}/" | awk -F"/" '{printf("%s/%s\n", $(NF-1), $NF)}' | sed 's|^/||')) # Get a list of the module's dependencies
    if [[ -n "$3" ]]; then # If a color value is provided
        color=$((31 + $3 % 7)) # Set the color value based on the provided value
    else
        color=31 # Otherwise, set the color to the default value of 31
    fi
    for dep in "${deps[@]}"; do # For each dependency
        if [[ "$dep" == *.bak* ]]; then # If the dependency is a backup file
            continue # Skip it
        fi
        dir=$(dirname "$dep") # Get the directory name of the dependency
        file=$(basename "$dep") # Get the file name of the dependency
        echo -e " \e[${color}m$dir/$file\e[0m" # Print the dependency name in the specified color
        modepx "$dir/$file" "$2" $((color + 1)) # Call the modepx function recursively with the dependency name, search directory, and incremented color value
    done
}


